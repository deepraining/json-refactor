{"version":3,"file":"json-refactor.js","sources":["../src/util/logger.js","../src/util/type.js","../src/util/check.js","../src/marker.js","../src/convert/index.js","../src/convert/dot.js","../src/handle.js","../src/refactor.js","../src/register.js","../src/operator/int.js","../src/operator/float.js","../src/operator/sum.js","../src/operator/average.js","../src/index.js","../src/operator/bool.js","../src/operator/string.js","../src/set.js"],"sourcesContent":["const prefix = 'json-refactor: ';\n\nexport const log = (str, ...rest) => {\n  console.log(prefix + str, ...rest);\n};\n\nexport const info = (str, ...rest) => {\n  console.info(prefix + str, ...rest);\n};\n\nexport const warn = (str, ...rest) => {\n  console.warn(prefix + str, ...rest);\n};\n\nexport const error = (str, ...rest) => {\n  console.error(prefix + str, ...rest);\n};\n\nexport const throwError = str => {\n  throw new Error(prefix + str);\n};\n","// from jquery[https://github.com/jquery/jquery/blob/master/src/core.js#L271]\n\nconst class2type = {};\nconst { toString } = class2type;\n\n'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' ').forEach(name => {\n  class2type[`[object ${name}]`] = name.toLowerCase();\n});\n\nexport default function(obj) {\n  if (obj === null) return `${obj}`;\n\n  return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;\n}\n","import { error } from './logger';\nimport type from './type';\n\nexport default function(target, mapping) {\n  if (!target || typeof target !== 'object') {\n    error('target is invalid, it should be a map or an array');\n    error('target: ', target);\n    return !1;\n  }\n\n  if (!mapping || typeof mapping !== 'object') {\n    error('mapping rules is invalid, it should be a map or an array');\n    error('mapping rules: ', mapping);\n    return !1;\n  }\n\n  if (type(target) !== type(mapping)) {\n    error('target and mapping rules are not the same type, they should both be map or array');\n    error('target: ', target);\n    error('mapping rules: ', mapping);\n    return !1;\n  }\n\n  return !0;\n}\n","export default {\n  /**\n   * Make a new key, and keep on refactoring the new key.\n   *\n   * @example\n   *\n   * ```\n   * target: {list: [{}]}\n   *\n   * mapping: {data: 'list', _data: [{}]}\n   * ```\n   */\n  keepOnHandling: '_',\n  /**\n   * Delimiter of operators.\n   *\n   * @example\n   *\n   * ```\n   * mapping: {toKey: 'fromKey|operator1|operator2|operator3'}\n   * ```\n   */\n  operatorDelimiter: '|',\n};\n","import marker from '../marker';\nimport type from '../util/type';\nimport operations from '../operations';\nimport dotConvert from './dot';\n\n/**\n * Convert target based on `mapping` and `toKey`.\n *\n * @param target\n * @param mapping\n * @param toKey\n */\nexport default function(target, mapping, toKey) {\n  /* eslint-disable no-param-reassign */\n\n  // `fromKey|operator1|operator2|operator3`\n  const fullFromKey = mapping[toKey];\n\n  // [fromKey, operator1, operator2, operator3]\n  const fullFromKeyItems = fullFromKey.split(marker.operatorDelimiter);\n\n  // Real from key.\n  const fromKey = fullFromKeyItems.shift();\n\n  // All operators.\n  const operators = fullFromKeyItems;\n\n  // Has dot mark.\n  if (fromKey.indexOf('.') > -1) target[toKey] = dotConvert(target, fromKey);\n  // Base.\n  else target[toKey] = target[fromKey];\n\n  // Operators and operations.\n  operators.forEach(operator => {\n    operations.forEach(operation => {\n      if (typeof operation.test === 'string') {\n        // string\n\n        if (operator === operation.test) target[toKey] = operation.handler(target[toKey], operator);\n      } else if (type(operation.test) === 'regexp') {\n        // RegExp\n\n        if (operation.test.test(operator)) target[toKey] = operation.handler(target[toKey], operator);\n      }\n    });\n  });\n}\n","import clone from 'clone';\n\nexport default function(target, fromKey) {\n  // [key, subKey, subSubKey, ...]\n  const fromKeyItems = fromKey.split('.');\n  let result;\n\n  let tempTarget = target;\n  let tempKey;\n\n  for (let i = 0; i < fromKeyItems.length; i += 1) {\n    tempKey = fromKeyItems[i];\n\n    if (typeof tempTarget[tempKey] !== 'undefined') {\n      // Has value, continue.\n\n      tempTarget = tempTarget[tempKey];\n      result = tempTarget;\n    } else {\n      // No value, break.\n\n      result = undefined;\n      break;\n    }\n  }\n\n  // Not found.\n  if (typeof result === 'undefined') return;\n\n  // Is `object[array|map]` and not `null`, clone it.\n  return result && typeof result === 'object' ? clone(result) : result;\n}\n","import check from './util/check';\nimport { error } from './util/logger';\nimport marker from './marker';\nimport convert from './convert';\n\n/**\n * Handle function.\n *\n * @param target Target to handle.\n * @param mapping Mapping rules.\n */\nconst handle = (target, mapping) => {\n  if (!check(target, mapping)) return;\n\n  // array\n  if (Array.isArray(mapping))\n    target.forEach(item => {\n      handle(item, mapping[0]);\n    });\n  // map\n  else\n    Object.keys(mapping).forEach(toKey => {\n      /**\n       * Just copy value of `fromKey` to `toKey`.\n       *\n       * @example\n       *\n       * ```\n       * {toKey: fromKey}\n       * ```\n       */\n      const fromKey = mapping[toKey];\n\n      let oldValue = target[toKey];\n\n      // {data: 'list', _data: [{...}]}\n      if (toKey.slice(0, marker.keepOnHandling.length) === marker.keepOnHandling) {\n        oldValue = target[toKey.slice(marker.keepOnHandling.length)];\n      }\n\n      if (typeof fromKey === 'object') {\n        /**\n         * `fromKey` is object.\n         *\n         * @example\n         *\n         * ```\n         * {key: {...}}\n         * {key: [{...}]}\n         * ```\n         */\n\n        if (!check(oldValue, fromKey)) return;\n\n        // array\n        if (Array.isArray(fromKey)) {\n          oldValue.forEach(item => {\n            if (!check(item, fromKey[0])) return;\n\n            handle(item, fromKey[0]);\n          });\n        }\n        // map\n        else {\n          handle(oldValue, fromKey);\n        }\n      } else if (typeof fromKey === 'string') {\n        /**\n         * `fromKey` is string.\n         *\n         * @example\n         *\n         * ```\n         * {toKey: fromKey}\n         * ```\n         */\n\n        convert(target, mapping, toKey);\n      } else {\n        // Others.\n\n        error(`can't resolve key: ${JSON.stringify(fromKey)}`);\n      }\n    });\n};\n\nexport default handle;\n","import clone from 'clone';\nimport check from './util/check';\nimport handle from './handle';\n\n/**\n * Main\n *\n * @param target Target to handle.\n * @param mapping Mapping rules to refactor.\n * @param cloneTarget Whether to clone target, if `true`, a new cloned target will be formatted, and the original target will not be modified. Default `false`, the original target will be modified.\n */\nexport default function(target, mapping, cloneTarget) {\n  if (!check(target, mapping)) return target;\n\n  const newTarget = cloneTarget ? clone(target) : target;\n\n  handle(newTarget, mapping);\n\n  return newTarget;\n}\n","import operations from './operations';\n\n/**\n * Register an operator.\n *\n * @param test\n * @param handler\n */\nexport default function(test, handler) {\n  if (!test) return;\n\n  // string/regExp + handler\n  if (test && handler) operations.push({ test, handler });\n  // map or array\n  else if (typeof test === 'object') {\n    // [{test, handler}, {...}]\n    if (Array.isArray(test)) operations.push(...test);\n    // {test, handler}\n    else operations.push(test);\n  }\n}\n","export default {\n  test: 'int',\n  handler: value => parseInt(value, 10),\n};\n","export default {\n  test: 'float',\n  handler: value => parseFloat(value),\n};\n","import { error } from '../util/logger';\n\nexport default {\n  test: /^sum!/,\n  handler: (value, operator) => {\n    const field = operator.split('!')[1];\n    let sum = 0;\n\n    if (!field) {\n      error(`'${operator}' is not a valid operator.`);\n      return sum;\n    }\n\n    if (!value || !Array.isArray(value)) {\n      error(`original value should be an array for operator '${operator}'.`, value);\n      return sum;\n    }\n\n    value.forEach(item => {\n      sum += item[field];\n    });\n\n    return sum;\n  },\n};\n","import { error } from '../util/logger';\n\nexport default {\n  test: /^average!/,\n  handler: (value, operator) => {\n    const field = operator.split('!')[1];\n    let sum = 0;\n    let count = 0;\n\n    if (!field) {\n      error(`'${operator}' is not a valid operator.`);\n      return sum;\n    }\n\n    if (!value || !Array.isArray(value)) {\n      error(`original value should be an array for operator '${operator}'.`, value);\n      return sum;\n    }\n\n    value.forEach(item => {\n      sum += item[field];\n      count += 1;\n    });\n\n    return sum / count;\n  },\n};\n","import refactor from './refactor';\nimport set from './set';\nimport register from './register';\nimport intOperator from './operator/int';\nimport floatOperator from './operator/float';\nimport boolOperator from './operator/bool';\nimport stringOperator from './operator/string';\nimport sumOperator from './operator/sum';\nimport averageOperator from './operator/average';\n\n// built-in operators\nregister(intOperator);\nregister(floatOperator);\nregister(boolOperator);\nregister(stringOperator);\nregister(sumOperator);\nregister(averageOperator);\n\nrefactor.set = set;\nrefactor.register = register;\n\nexport default refactor;\n","export default {\n  test: 'bool',\n  handler: value => !!value,\n};\n","export default {\n  test: 'string',\n  handler: value => `${value}`,\n};\n","import marker from './marker';\n\n/**\n * Set custom markers.\n *\n * @param options\n */\nexport default function(options) {\n  if (!options || typeof options !== 'object') return;\n\n  Object.keys(options).forEach(key => {\n    marker[key] = options[key];\n  });\n}\n"],"names":["error","str","console","rest","class2type","obj","toString","call","target","mapping","type","split","forEach","name","toLowerCase","keepOnHandling","operatorDelimiter","toKey","const","fullFromKeyItems","marker","fromKey","shift","operators","indexOf","result","tempKey","fromKeyItems","tempTarget","i","length","undefined","clone","dotConvert","operator","operations","operation","test","handler","handle","check","Array","isArray","item","Object","keys","oldValue","slice","convert","JSON","stringify","cloneTarget","newTarget","push","value","parseFloat","field","sum","count","register","parseInt","floatOperator","sumOperator","averageOperator","refactor","set","options","key"],"mappings":"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"}