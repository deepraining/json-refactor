{"version":3,"file":"json-refactor.js","sources":["../src/util/logger.js","../src/util/type.js","../src/util/check.js","../src/marker.js","../src/operations.js","../src/convert/dot.js","../src/convert/index.js","../src/handle.js","../src/refactor.js","../src/set.js","../src/register.js","../src/operator/int.js","../src/operator/float.js","../src/operator/bool.js","../src/operator/string.js","../src/operator/sum.js","../src/operator/average.js","../src/index.js"],"sourcesContent":["const prefix = 'json-refactor: ';\n\nexport const log = (str, ...rest) => {\n  console.log(prefix + str, ...rest);\n};\n\nexport const info = (str, ...rest) => {\n  console.info(prefix + str, ...rest);\n};\n\nexport const warn = (str, ...rest) => {\n  console.warn(prefix + str, ...rest);\n};\n\nexport const error = (str, ...rest) => {\n  console.error(prefix + str, ...rest);\n};\n\nexport const throwError = str => {\n  throw new Error(prefix + str);\n};\n","// from jquery[https://github.com/jquery/jquery/blob/master/src/core.js#L271]\n\nconst class2type = {};\nconst { toString } = class2type;\n\n'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' ').forEach(name => {\n  class2type[`[object ${name}]`] = name.toLowerCase();\n});\n\nexport default function(obj) {\n  if (obj === null) return `${obj}`;\n\n  return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;\n}\n","import { error } from './logger';\nimport type from './type';\n\nexport default function(target, keysMap) {\n  if (!target || typeof target !== 'object') {\n    error('target is invalid, it should be a map or an array');\n    error('target: ', target);\n    return !1;\n  }\n\n  if (!keysMap || typeof keysMap !== 'object') {\n    error('keysMap is invalid, it should be a map or an array');\n    error('keysMap: ', keysMap);\n    return !1;\n  }\n\n  if (type(target) !== type(keysMap)) {\n    error('target and keysMap are not the same type, they both should be map or array');\n    error('target: ', target);\n    error('keysMap: ', keysMap);\n    return !1;\n  }\n\n  return !0;\n}\n","export default {\n  /**\n   * Make a new key, and keep on refactoring the new key.\n   *\n   * @example\n   *\n   * ```\n   * target: {list: [{}]}\n   *\n   * keysMap: {data: 'list', _data: [{}]}\n   * ```\n   */\n  keepOnHandling: '_',\n  /**\n   * Delimiter of operators.\n   *\n   * @example\n   *\n   * ```\n   * keysMap: {toKey: 'fromKey|operator1|operator2|operator3'}\n   * ```\n   */\n  operatorDelimiter: '|',\n};\n","/**\n * Operations collection.\n *\n * @type {Array}\n */\nexport default [\n  /**\n   * {\n   *   test: string/RegExp\n   *   // value: original value of current key\n   *   // operator: operator of current handling\n   *   handler: (value, operator) => {\n   *\n   *     // Should return a new value at last.\n   *     return newValue;\n   *   }\n   * }\n   */\n];\n","import clone from 'clone';\n\nexport default function(target, fromKey) {\n  // [key, subKey, subSubKey, ...]\n  const fromKeyItems = fromKey.split('.');\n  let result;\n\n  let tempTarget = target;\n  let tempKey;\n\n  for (let i = 0; i < fromKeyItems.length; i += 1) {\n    tempKey = fromKeyItems[i];\n\n    if (typeof tempTarget[tempKey] !== 'undefined') {\n      // Has value, continue.\n\n      tempTarget = tempTarget[tempKey];\n      result = tempTarget;\n    } else {\n      // No value, break.\n\n      result = undefined;\n      break;\n    }\n  }\n\n  // Not found.\n  if (typeof result === 'undefined') return;\n\n  // Is `object[array|map]` and not `null`, clone it.\n  return result && typeof result === 'object' ? clone(result) : result;\n}\n","import marker from '../marker';\nimport type from '../util/type';\nimport operations from '../operations';\nimport dotConvert from './dot';\n\n/**\n * Convert target based on `keysMap` and `toKey`.\n *\n * @param target\n * @param keysMap\n * @param toKey\n */\nexport default function(target, keysMap, toKey) {\n  /* eslint-disable no-param-reassign */\n\n  // `fromKey|operator1|operator2|operator3`\n  const fullFromKey = keysMap[toKey];\n\n  // [fromKey, operator1, operator2, operator3]\n  const fullFromKeyItems = fullFromKey.split(marker.operatorDelimiter);\n\n  // Real from key.\n  const fromKey = fullFromKeyItems.shift();\n\n  // All operators.\n  const operators = fullFromKeyItems;\n\n  // Has dot mark.\n  if (fromKey.indexOf('.') > -1) target[toKey] = dotConvert(target, fromKey);\n  // Base.\n  else target[toKey] = target[fromKey];\n\n  // Operators and operations.\n  operators.forEach(operator => {\n    operations.forEach(operation => {\n      if (typeof operation.test === 'string') {\n        // string\n\n        if (operator === operation.test) target[toKey] = operation.handler(target[toKey], operator);\n      } else if (type(operation.test) === 'regexp') {\n        // RegExp\n\n        if (operation.test.test(operator)) target[toKey] = operation.handler(target[toKey], operator);\n      }\n    });\n  });\n}\n","import check from './util/check';\nimport { error } from './util/logger';\nimport marker from './marker';\nimport convert from './convert';\n\n/**\n * Handle function.\n *\n * @param target Target to handle.\n * @param keysMap Rules\n */\nconst handle = (target, keysMap) => {\n  if (!check(target, keysMap)) return;\n\n  // array\n  if (Array.isArray(keysMap))\n    target.forEach(item => {\n      handle(item, keysMap[0]);\n    });\n  // map\n  else\n    Object.keys(keysMap).forEach(toKey => {\n      /**\n       * Just copy value of `fromKey` to `toKey`.\n       *\n       * @example\n       *\n       * ```\n       * {toKey: fromKey}\n       * ```\n       */\n      const fromKey = keysMap[toKey];\n\n      let oldValue = target[toKey];\n\n      // {data: 'list', _data: [{...}]}\n      if (toKey.slice(0, marker.keepOnHandling.length) === marker.keepOnHandling) {\n        oldValue = target[toKey.slice(marker.keepOnHandling.length)];\n      }\n\n      if (typeof fromKey === 'object') {\n        /**\n         * `fromKey` is object.\n         *\n         * @example\n         *\n         * ```\n         * {key: {...}}\n         * {key: [{...}]}\n         * ```\n         */\n\n        if (!check(oldValue, fromKey)) return;\n\n        // array\n        if (Array.isArray(fromKey)) {\n          oldValue.forEach(item => {\n            if (!check(item, fromKey[0])) return;\n\n            handle(item, fromKey[0]);\n          });\n        }\n        // map\n        else {\n          handle(oldValue, fromKey);\n        }\n      } else if (typeof fromKey === 'string') {\n        /**\n         * `fromKey` is string.\n         *\n         * @example\n         *\n         * ```\n         * {toKey: fromKey}\n         * ```\n         */\n\n        convert(target, keysMap, toKey);\n      } else {\n        // Others.\n\n        error(`can't resolve key: ${JSON.stringify(fromKey)}`);\n      }\n    });\n};\n\nexport default handle;\n","import clone from 'clone';\nimport check from './util/check';\nimport handle from './handle';\n\n/**\n * Main\n *\n * @param target Target to handle.\n * @param keysMap Keys map to refactor.\n * @param returnNew Whether return new json, if true, a new clone target will be return, and the original target will be not be modified.\n */\nexport default function(target, keysMap, returnNew) {\n  if (!check(target, keysMap)) return target;\n\n  const newTarget = returnNew ? clone(target) : target;\n\n  handle(newTarget, keysMap);\n\n  return newTarget;\n}\n","import marker from './marker';\n\n/**\n * Set custom markers.\n *\n * @param options\n */\nexport default function(options) {\n  if (!options || typeof options !== 'object') return;\n\n  Object.keys(options).forEach(key => {\n    marker[key] = options[key];\n  });\n}\n","import operations from './operations';\n\n/**\n * Register an operator.\n *\n * @param test\n * @param handler\n */\nexport default function(test, handler) {\n  if (!test) return;\n\n  // string/regExp + handler\n  if (test && handler) operations.push({ test, handler });\n  // map or array\n  else if (typeof test === 'object') {\n    // [{test, handler}, {...}]\n    if (Array.isArray(test)) operations.push(...test);\n    // {test, handler}\n    else operations.push(test);\n  }\n}\n","export default {\n  test: 'int',\n  handler: value => parseInt(value, 10),\n};\n","export default {\n  test: 'float',\n  handler: value => parseFloat(value),\n};\n","export default {\n  test: 'bool',\n  handler: value => !!value,\n};\n","export default {\n  test: 'string',\n  handler: value => `${value}`,\n};\n","import { error } from '../util/logger';\n\nexport default {\n  test: /^sum!/,\n  handler: (value, operator) => {\n    const field = operator.split('!')[1];\n    let sum = 0;\n\n    if (!field) {\n      error(`'${operator}' is not a valid operator.`);\n      return sum;\n    }\n\n    if (!value || !Array.isArray(value)) {\n      error(`original value should be an array for operator '${operator}'.`, value);\n      return sum;\n    }\n\n    value.forEach(item => {\n      sum += item[field];\n    });\n\n    return sum;\n  },\n};\n","import { error } from '../util/logger';\n\nexport default {\n  test: /^average!/,\n  handler: (value, operator) => {\n    const field = operator.split('!')[1];\n    let sum = 0;\n    let count = 0;\n\n    if (!field) {\n      error(`'${operator}' is not a valid operator.`);\n      return sum;\n    }\n\n    if (!value || !Array.isArray(value)) {\n      error(`original value should be an array for operator '${operator}'.`, value);\n      return sum;\n    }\n\n    value.forEach(item => {\n      sum += item[field];\n      count += 1;\n    });\n\n    return sum / count;\n  },\n};\n","import refactor from './refactor';\nimport set from './set';\nimport register from './register';\nimport intOperator from './operator/int';\nimport floatOperator from './operator/float';\nimport boolOperator from './operator/bool';\nimport stringOperator from './operator/string';\nimport sumOperator from './operator/sum';\nimport averageOperator from './operator/average';\n\n// built-in operators\nregister(intOperator);\nregister(floatOperator);\nregister(boolOperator);\nregister(stringOperator);\nregister(sumOperator);\nregister(averageOperator);\n\nrefactor.set = set;\nrefactor.register = register;\n\nexport default refactor;\n"],"names":["const","let"],"mappings":"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"}