{"version":3,"file":"json-refactor.umd.js","sources":["../src/util/logger.js","../src/util/type.js","../src/util/check.js","../src/marker.js","../src/operations.js","../src/convert/dot.js","../src/convert/index.js","../src/handle.js","../src/refactor.js","../src/set.js","../src/register.js","../src/operator/int.js","../src/operator/float.js","../src/operator/bool.js","../src/operator/string.js","../src/operator/sum.js","../src/operator/average.js","../src/index.js"],"sourcesContent":["const prefix = 'json-refactor: ';\n\nexport const log = (str, ...rest) => {\n  console.log(prefix + str, ...rest);\n};\n\nexport const info = (str, ...rest) => {\n  console.info(prefix + str, ...rest);\n};\n\nexport const warn = (str, ...rest) => {\n  console.warn(prefix + str, ...rest);\n};\n\nexport const error = (str, ...rest) => {\n  console.error(prefix + str, ...rest);\n};\n\nexport const throwError = str => {\n  throw new Error(prefix + str);\n};\n","// from jquery[https://github.com/jquery/jquery/blob/master/src/core.js#L271]\n\nconst class2type = {};\nconst { toString } = class2type;\n\n'Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' ').forEach(name => {\n  class2type[`[object ${name}]`] = name.toLowerCase();\n});\n\nexport default function(obj) {\n  if (obj === null) return `${obj}`;\n\n  return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;\n}\n","import { error } from './logger';\nimport type from './type';\n\nexport default function(target, keysMap) {\n  if (!target || typeof target !== 'object') {\n    error('target is invalid, it should be a map or an array');\n    error('target: ', target);\n    return !1;\n  }\n\n  if (!keysMap || typeof keysMap !== 'object') {\n    error('keysMap is invalid, it should be a map or an array');\n    error('keysMap: ', keysMap);\n    return !1;\n  }\n\n  if (type(target) !== type(keysMap)) {\n    error('target and keysMap are not the same type, they both should be map or array');\n    error('target: ', target);\n    error('keysMap: ', keysMap);\n    return !1;\n  }\n\n  return !0;\n}\n","export default {\n  /**\n   * Make a new key, and keep on refactoring the new key.\n   *\n   * @example\n   *\n   * ```\n   * target: {list: [{}]}\n   *\n   * keysMap: {data: 'list', _data: [{}]}\n   * ```\n   */\n  keepOnHandling: '_',\n  /**\n   * Delimiter of operators.\n   *\n   * @example\n   *\n   * ```\n   * keysMap: {toKey: 'fromKey|operator1|operator2|operator3'}\n   * ```\n   */\n  operatorDelimiter: '|',\n};\n","/**\n * Operations collection.\n *\n * @type {Array}\n */\nexport default [\n  /**\n   * {\n   *   test: string/RegExp\n   *   // value: original value of current key\n   *   // operator: operator of current handling\n   *   handler: (value, operator) => {\n   *\n   *     // Should return a new value at last.\n   *     return newValue;\n   *   }\n   * }\n   */\n];\n","import clone from 'clone';\n\nexport default function(target, fromKey) {\n  // [key, subKey, subSubKey, ...]\n  const fromKeyItems = fromKey.split('.');\n  let result;\n\n  let tempTarget = target;\n  let tempKey;\n\n  for (let i = 0; i < fromKeyItems.length; i += 1) {\n    tempKey = fromKeyItems[i];\n\n    if (typeof tempTarget[tempKey] !== 'undefined') {\n      // Has value, continue.\n\n      tempTarget = tempTarget[tempKey];\n      result = tempTarget;\n    } else {\n      // No value, break.\n\n      result = undefined;\n      break;\n    }\n  }\n\n  // Not found.\n  if (typeof result === 'undefined') return;\n\n  // Is `object[array|map]` and not `null`, clone it.\n  return result && typeof result === 'object' ? clone(result) : result;\n}\n","import marker from '../marker';\nimport type from '../util/type';\nimport operations from '../operations';\nimport dotConvert from './dot';\n\n/**\n * Convert target based on `keysMap` and `toKey`.\n *\n * @param target\n * @param keysMap\n * @param toKey\n */\nexport default function(target, keysMap, toKey) {\n  /* eslint-disable no-param-reassign */\n\n  // `fromKey|operator1|operator2|operator3`\n  const fullFromKey = keysMap[toKey];\n\n  // [fromKey, operator1, operator2, operator3]\n  const fullFromKeyItems = fullFromKey.split(marker.operatorDelimiter);\n\n  // Real from key.\n  const fromKey = fullFromKeyItems.shift();\n\n  // All operators.\n  const operators = fullFromKeyItems;\n\n  // Has dot mark.\n  if (fromKey.indexOf('.') > -1) target[toKey] = dotConvert(target, fromKey);\n  // Base.\n  else target[toKey] = target[fromKey];\n\n  // Operators and operations.\n  operators.forEach(operator => {\n    operations.forEach(operation => {\n      if (typeof operation.test === 'string') {\n        // string\n\n        if (operator === operation.test) target[toKey] = operation.handler(target[toKey], operator);\n      } else if (type(operation.test) === 'regexp') {\n        // RegExp\n\n        if (operation.test.test(operator)) target[toKey] = operation.handler(target[toKey], operator);\n      }\n    });\n  });\n}\n","import check from './util/check';\nimport { error } from './util/logger';\nimport marker from './marker';\nimport convert from './convert';\n\n/**\n * Handle function.\n *\n * @param target Target to handle.\n * @param keysMap Rules\n */\nconst handle = (target, keysMap) => {\n  if (!check(target, keysMap)) return;\n\n  // array\n  if (Array.isArray(keysMap))\n    target.forEach(item => {\n      handle(item, keysMap[0]);\n    });\n  // map\n  else\n    Object.keys(keysMap).forEach(toKey => {\n      /**\n       * Just copy value of `fromKey` to `toKey`.\n       *\n       * @example\n       *\n       * ```\n       * {toKey: fromKey}\n       * ```\n       */\n      const fromKey = keysMap[toKey];\n\n      let oldValue = target[toKey];\n\n      // {data: 'list', _data: [{...}]}\n      if (toKey.slice(0, marker.keepOnHandling.length) === marker.keepOnHandling) {\n        oldValue = target[toKey.slice(marker.keepOnHandling.length)];\n      }\n\n      if (typeof fromKey === 'object') {\n        /**\n         * `fromKey` is object.\n         *\n         * @example\n         *\n         * ```\n         * {key: {...}}\n         * {key: [{...}]}\n         * ```\n         */\n\n        if (!check(oldValue, fromKey)) return;\n\n        // array\n        if (Array.isArray(fromKey)) {\n          oldValue.forEach(item => {\n            if (!check(item, fromKey[0])) return;\n\n            handle(item, fromKey[0]);\n          });\n        }\n        // map\n        else {\n          handle(oldValue, fromKey);\n        }\n      } else if (typeof fromKey === 'string') {\n        /**\n         * `fromKey` is string.\n         *\n         * @example\n         *\n         * ```\n         * {toKey: fromKey}\n         * ```\n         */\n\n        convert(target, keysMap, toKey);\n      } else {\n        // Others.\n\n        error(`can't resolve key: ${JSON.stringify(fromKey)}`);\n      }\n    });\n};\n\nexport default handle;\n","import clone from 'clone';\nimport check from './util/check';\nimport handle from './handle';\n\n/**\n * Main\n *\n * @param target Target to handle.\n * @param keysMap Keys map to refactor.\n * @param returnNew Whether return new json, if true, a new clone target will be return, and the original target will be not be modified.\n */\nexport default function(target, keysMap, returnNew) {\n  if (!check(target, keysMap)) return target;\n\n  const newTarget = returnNew ? clone(target) : target;\n\n  handle(newTarget, keysMap);\n\n  return newTarget;\n}\n","import marker from './marker';\n\n/**\n * Set custom markers.\n *\n * @param options\n */\nexport default function(options) {\n  if (!options || typeof options !== 'object') return;\n\n  Object.keys(options).forEach(key => {\n    marker[key] = options[key];\n  });\n}\n","import operations from './operations';\n\n/**\n * Register an operator.\n *\n * @param test\n * @param handler\n */\nexport default function(test, handler) {\n  if (!test) return;\n\n  // string/regExp + handler\n  if (test && handler) operations.push({ test, handler });\n  // map or array\n  else if (typeof test === 'object') {\n    // [{test, handler}, {...}]\n    if (Array.isArray(test)) operations.push(...test);\n    // {test, handler}\n    else operations.push(test);\n  }\n}\n","export default {\n  test: 'int',\n  handler: value => parseInt(value, 10),\n};\n","export default {\n  test: 'float',\n  handler: value => parseFloat(value),\n};\n","export default {\n  test: 'bool',\n  handler: value => !!value,\n};\n","export default {\n  test: 'string',\n  handler: value => `${value}`,\n};\n","import { error } from '../util/logger';\n\nexport default {\n  test: /^sum!/,\n  handler: (value, operator) => {\n    const field = operator.split('!')[1];\n    let sum = 0;\n\n    if (!field) {\n      error(`'${operator}' is not a valid operator.`);\n      return sum;\n    }\n\n    if (!value || !Array.isArray(value)) {\n      error(`original value should be an array for operator '${operator}'.`, value);\n      return sum;\n    }\n\n    value.forEach(item => {\n      sum += item[field];\n    });\n\n    return sum;\n  },\n};\n","import { error } from '../util/logger';\n\nexport default {\n  test: /^average!/,\n  handler: (value, operator) => {\n    const field = operator.split('!')[1];\n    let sum = 0;\n    let count = 0;\n\n    if (!field) {\n      error(`'${operator}' is not a valid operator.`);\n      return sum;\n    }\n\n    if (!value || !Array.isArray(value)) {\n      error(`original value should be an array for operator '${operator}'.`, value);\n      return sum;\n    }\n\n    value.forEach(item => {\n      sum += item[field];\n      count += 1;\n    });\n\n    return sum / count;\n  },\n};\n","import refactor from './refactor';\nimport set from './set';\nimport register from './register';\nimport intOperator from './operator/int';\nimport floatOperator from './operator/float';\nimport boolOperator from './operator/bool';\nimport stringOperator from './operator/string';\nimport sumOperator from './operator/sum';\nimport averageOperator from './operator/average';\n\n// built-in operators\nregister(intOperator);\nregister(floatOperator);\nregister(boolOperator);\nregister(stringOperator);\nregister(sumOperator);\nregister(averageOperator);\n\nrefactor.set = set;\nrefactor.register = register;\n\nexport default refactor;\n"],"names":["const","let"],"mappings":"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"}